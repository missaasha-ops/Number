<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>THE BDT PREDICTOR V.5 (AI Big/Small + Top3 Numbers)</title>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Outfit', sans-serif; background: #000; color: #fff; margin: 0; padding: 10px; text-align: center; }
    .header { font-size: 20px; font-weight: bold; color: #00ffea; margin-bottom: 10px; }
    .card { background: #111; border: 1px solid #00ffea; border-radius: 10px; padding: 10px; margin-bottom: 12px; }
    .prediction-btn { margin: 10px auto; display: block; background: #00ffea33; color: #00ffea; border: 1px solid #00ffea;
      border-radius: 8px; padding: 12px; font-weight: bold; font-size: 18px; width: 90%; }
    #patternBox { color: #aaa; font-size: 14px; margin-top: 5px; }
    .tab-buttons { display: flex; border: 1px solid #00ffea; border-radius: 8px; overflow: hidden; margin-bottom: 10px; }
    .tab-buttons button { flex: 1; background: #111; color: #00ffea; padding: 8px; border: none; cursor: pointer; font-weight: bold; }
    .tab-buttons button.active { background: #00ffea33; }
    .history-container { border: 1px solid #00ffea; border-radius: 8px; overflow: hidden; max-height: 400px; overflow-y: auto; }
    table { width: 100%; border-collapse: collapse; }
    th, td { font-size: 13px; border-bottom: 1px solid #222; padding: 6px; }
    th { background: #111; color: #00ffea; position: sticky; top: 0; }
    .status.win { color: lime; font-weight: bold; }
    .status.loss { color: red; font-weight: bold; }
    .status.Waiting { color: yellow; font-weight: bold; }
  </style>
</head>
<body>
  <div class="header">ğ“ğ‡ğ„ ğ€ğˆ ğğ‘ğ„ğƒğˆğ‚ğ“ğğ‘ V5.1 (Top 3 Numbers)</div>
  <div class="card">
    <div id="currentPeriod">à¤µà¤°à¥à¤¤à¤®à¤¾à¤¨ à¤ªà¥€à¤°à¤¿à¤¯à¤¡: Loading...</div>
    <div id="liveTime">à¤¸à¤®à¤¯: --:--:--</div>
    <div id="predictionBox" class="prediction-btn">Big/Small â†’ Analyzing...</div>
    <div id="confidenceBox">Confidence: --%</div>
    <div id="numberPredictionBox">Predicted Winning Numbers â†’ --</div>
    <div id="patternBox">Pattern: --</div>
    <div id="winRate" class="win-rate">Win Rate: --%</div>
  </div>

  <div class="tab-buttons">
    <button id="predTab" class="active">Prediction History</button>
    <button id="gameTab">Game History</button>
  </div>

  <div class="history-container">
    <table>
      <thead id="tableHead"></thead>
      <tbody id="tableBody"><tr><td>Loading...</td></tr></tbody>
    </table>
  </div>

<script>
/* ====== Configuration ====== */
const CURRENT_API = 'https://api.bdg88zf.com/api/webapi/GetGameIssue';
const HISTORY_API = 'https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json';

const REQUEST_DATA = {
  typeId: 1,
  language: 0,
  random: "e7fe6c090da2495ab8290dac551ef1ed",
  signature: "1F390E2B2D8A55D693E57FD905AE73A7",
  timestamp: 1723726679
};

/* ====== State ====== */
let predictionHistory = [];
let last100Results = [];
let winCount = 0;
let lossCount = 0;

/* Load persisted state if present */
function loadState() {
  try {
    const ph = localStorage.getItem('predictionHistory_v5');
    const wl = localStorage.getItem('winloss_v5');
    if (ph) predictionHistory = JSON.parse(ph);
    if (wl) {
      const obj = JSON.parse(wl);
      winCount = obj.win || 0;
      lossCount = obj.loss || 0;
    }
  } catch(e) { console.warn("Load state error", e); }
}
function saveState() {
  try {
    localStorage.setItem('predictionHistory_v5', JSON.stringify(predictionHistory));
    localStorage.setItem('winloss_v5', JSON.stringify({ win: winCount, loss: lossCount }));
  } catch(e) { console.warn("Save state error", e); }
}

/* ====== Helpers ====== */
function getBigSmall(num) { return num >= 5 ? "Big" : "Small"; }
function getColor(num) {
  if ([1, 3, 7, 9].includes(num)) return "Green";
  if ([2, 4, 6, 8].includes(num)) return "Red";
  return "Violet";
}
function updateLiveTime() { document.getElementById("liveTime").innerText = "à¤¸à¤®à¤¯: " + new Date().toLocaleTimeString('en-GB'); }

/* ====== Prediction Logic (Top 3 with confidences) ====== */
function bigSmallPrediction(history) {
  let bigCount = 0, smallCount = 0;
  history.forEach(h => { if (h.size === "Big") bigCount++; else smallCount++; });
  const prediction = bigCount > smallCount ? "Small" : "Big"; // contrarian choice in original; keep same
  return { text: prediction, conf: 72, pattern: "Trend-based" };
}

function analyzeNumbers(history) {
  // history is expected to be array of {number: x}
  const numbers = Array.from({length:10}, (_,i)=>i);
  const stats = {};
  numbers.forEach(num => { stats[num] = { frequency: 0, missing: 0 }; });
  // We'll compute frequency and consecutive missing counts
  // For missing, we reset counter when number seen; otherwise increment
  // Initialize missing to 0 and compute by scanning history newest->oldest
  const lastSeen = {}; numbers.forEach(n => lastSeen[n]=null);

  // Count frequency
  history.forEach((item) => {
    const n = Number(item.number);
    if (!isNaN(n) && stats.hasOwnProperty(n)) stats[n].frequency++;
  });

  // For missing: find distance since last seen (0 if seen in most recent)
  // We'll assume history[0] is most recent
  for (let i=0;i<history.length;i++) {
    const n = Number(history[i].number);
    if (lastSeen[n] === null) lastSeen[n] = i;
  }
  numbers.forEach(n => {
    if (lastSeen[n] === null) stats[n].missing = history.length; // not seen at all in provided history
    else stats[n].missing = lastSeen[n]; // how many draws since last seen (smaller means seen more recently)
  });

  return stats;
}

function predict(history) {
  // history should be recent history (e.g., last 20)
  if (history.length < 5) {
    return {
      text: "Analyzing...",
      conf: "--",
      pattern: "Awaiting data",
      numbers: ["--","--","--"],
      numConf: ["--","--","--"]
    };
  }

  const basePrediction = bigSmallPrediction(history);

  // Use last100Results (global) for number stats for a broader view
  const stats = analyzeNumbers(last100Results.length ? last100Results : history);

  // Sort primarily by frequency (desc). Tie-breaker: prefer smaller 'missing' (seen more recently)
  const sortedByHot = Object.entries(stats).sort((a,b) => {
    if (b[1].frequency !== a[1].frequency) return b[1].frequency - a[1].frequency;
    return a[1].missing - b[1].missing;
  });

  // Prepare top 3 candidates
  const top3 = sortedByHot.slice(0,3).map((entry, idx) => {
    const num = Number(entry[0]);
    // Confidence heuristic:
    // base 80 for top, then slightly decrease; adjust by frequency proportion if available
    const freq = entry[1].frequency;
    const totalFreq = Object.values(stats).reduce((s,x)=>s+x.frequency,0) || 1;
    const freqScore = Math.round((freq / totalFreq) * 100); // 0-100 rough
    const baseConf = 80 - idx*5;
    const conf = Math.min(95, Math.max(30, Math.round(baseConf + freqScore * 0.15))); // clamp
    return { number: num, conf };
  });

  return {
    text: basePrediction.text,
    conf: basePrediction.conf,
    pattern: "AI Hot Trend Analysis (Top 3)",
    numbers: top3.map(n=>n.number),
    numConf: top3.map(n=>n.conf)
  };
}

/* ====== UI + Fetch ====== */
function updateWinRate() {
  const total = winCount + lossCount;
  const winRate = total > 0 ? Math.round((winCount / total) * 100) : 0;
  document.getElementById("winRate").innerText = `Win Rate: ${winRate}% (${winCount}W/${lossCount}L)`;
}

function renderTable() {
  const head = document.getElementById("tableHead");
  const body = document.getElementById("tableBody");

  if (document.getElementById("predTab").classList.contains("active")) {
    head.innerHTML = "<tr><th>Period</th><th>Big/Small Pred</th><th>Top Numbers (conf)</th><th>Actual</th><th>Status</th></tr>";
    body.innerHTML = predictionHistory.length === 0
      ? "<tr><td colspan='5'>à¤•à¥‹à¤ˆ prediction à¤…à¤­à¥€ à¤¤à¤• à¤¨à¤¹à¥€à¤‚</td></tr>"
      : predictionHistory.map(item => {
        const nums = (item.numberPreds || ["--","--","--"]).map((n,i)=> `${n} (${(item.numConfs||[])[i] ?? '--'}%)`).join(", ");
        return `
        <tr>
          <td>${item.period}</td>
          <td>${item.prediction}</td>
          <td>${nums}</td>
          <td>${item.actual} (${item.actualNum})</td>
          <td class="status ${item.status}">${item.status}</td>
        </tr>`;
      }).join("");
  } else {
    head.innerHTML = "<tr><th>Period</th><th>Number</th><th>Big/Small</th><th>Color</th></tr>";
    body.innerHTML = last100Results.length === 0
      ? "<tr><td colspan='4'>à¤•à¥‹à¤ˆ à¤‡à¤¤à¤¿à¤¹à¤¾à¤¸ à¤‰à¤ªà¤²à¤¬à¥à¤§ à¤¨à¤¹à¥€à¤‚</td></tr>"
      : last100Results.slice(0, 10).map(item => `
      <tr>
        <td>${item.period}</td>
        <td>${item.number}</td>
        <td>${item.size}</td>
        <td>${item.color}</td>
      </tr>`).join("");
  }
}

/* Fetch current period and recent history, then predict and update UI.
   Note: APIs used are the same as original. Keep interval reasonable. */
async function fetchData() {
  try {
    // Update current period (best-effort)
    try {
      const periodRes = await fetch(CURRENT_API, {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ...REQUEST_DATA, timestamp: Math.floor(Date.now() / 1000) })
      });
      const periodData = await periodRes.json();
      const period = periodData?.data?.issueNumber || "Unavailable";
      document.getElementById("currentPeriod").innerText = `à¤µà¤°à¥à¤¤à¤®à¤¾à¤¨ à¤ªà¥€à¤°à¤¿à¤¯à¤¡: ${period}`;
    } catch (e) {
      document.getElementById("currentPeriod").innerText = `à¤µà¤°à¥à¤¤à¤®à¤¾à¤¨ à¤ªà¥€à¤°à¤¿à¤¯à¤¡: Unavailable`;
      console.warn("Current API error", e);
    }

    // Fetch history
    const res = await fetch(HISTORY_API + '?ts=' + Date.now());
    const data = await res.json();
    if (!data?.data?.list) throw new Error("Invalid history data");

    last100Results = data.data.list.slice(0, 100).map(item => {
      const num = parseInt(item.number);
      return { period: item.issueNumber, number: num, size: getBigSmall(num), color: getColor(num) };
    });

    // Use recent subset for quick pattern (e.g., last 20)
    const recentHistory = last100Results.slice(0, 20);
    const prediction = predict(recentHistory);

    document.getElementById("predictionBox").innerText = `Big/Small â†’ ${prediction.text}`;
    document.getElementById("confidenceBox").innerText = `Confidence: ${prediction.conf}%`;
    document.getElementById("patternBox").innerText = `Pattern: ${prediction.pattern}`;

    // Show top 3 numbers with confidences
    let numberText = prediction.numbers.map((num, i) => `${num} (${prediction.numConf[i]}%)`).join(", ");
    document.getElementById("numberPredictionBox").innerText = `Predicted Winning Numbers â†’ ${numberText}`;

    // Record prediction for current period (avoid duplicates)
    const currentPeriod = document.getElementById("currentPeriod").innerText.split(":")[1]?.trim() || null;
    if (currentPeriod && currentPeriod !== "Unavailable") {
      // if not already recorded, add as a new waiting prediction
      if (!predictionHistory.find(p => p.period === currentPeriod)) {
        predictionHistory.unshift({
          period: currentPeriod,
          prediction: prediction.text,
          numberPreds: prediction.numbers,
          numConfs: prediction.numConf,
          actual: "--",
          actualNum: "--",
          status: "Waiting", // Waiting, Win, Loss
          resolved: false
        });
        // keep only latest 50 predictions
        if (predictionHistory.length > 50) predictionHistory.pop();
      }
    }

    // Resolve any waiting predictions by matching actuals in last100Results
    predictionHistory.forEach(ph => {
      if (!ph.resolved) {
        const match = last100Results.find(h => h.period === ph.period);
        if (match) {
          ph.actual = match.size;
          ph.actualNum = match.number;
          ph.status = (ph.prediction === match.size) ? "Win" : "Loss";
          ph.resolved = true;
          if (ph.status === "Win") winCount++; else lossCount++;
        }
      }
    });

    updateWinRate();
    saveState();
    renderTable();

  } catch (e) {
    console.error("Fetch error:", e);
    document.getElementById("predictionBox").innerText = "Prediction Error";
  }
}

/* ====== Tabs + Timer ====== */
document.querySelectorAll(".tab-buttons button").forEach(btn => {
  btn.addEventListener("click", () => {
    document.querySelectorAll(".tab-buttons button").forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    renderTable();
  });
});

/* ====== Init ====== */
loadState();
setInterval(updateLiveTime, 1000);
setInterval(fetchData, 7000); // every 7 seconds
fetchData();
renderTable();

</script>
</body>
</html>
