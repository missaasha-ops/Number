<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>THE AI PREDICTOR V5.4 (Full + History + Ding)</title>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Outfit', sans-serif; background: #000; color: #fff; margin: 0; padding: 12px; text-align: center; }
    .header { font-size: 20px; font-weight: bold; color: #00ffea; margin-bottom: 10px; }
    .card { background: #111; border: 1px solid #00ffea; border-radius: 10px; padding: 12px; margin-bottom: 12px; max-width: 900px; margin-left:auto; margin-right:auto; }
    .prediction-btn { margin: 10px auto; display: block; background: #00ffea22; color: #00ffea; border: 1px solid #00ffea; border-radius: 8px; padding: 12px; font-weight: bold; font-size: 18px; width: 92%; }
    #patternBox { color: #aaa; font-size: 14px; margin-top: 6px; }
    .tab-buttons { display: flex; border: 1px solid #00ffea; border-radius: 8px; overflow: hidden; margin: 12px auto; max-width: 900px; }
    .tab-buttons button { flex: 1; background: #111; color: #00ffea; padding: 10px; border: none; cursor: pointer; font-weight: bold; }
    .tab-buttons button.active { background: #00ffea33; }
    .history-container { border: 1px solid #00ffea; border-radius: 8px; overflow: hidden; max-height: 420px; overflow-y: auto; max-width: 900px; margin: 0 auto 40px; background:#0b0b0b; }
    table { width: 100%; border-collapse: collapse; }
    thead th { position: sticky; top: 0; background: #0c0c0c; color: #00ffea; padding: 8px; font-size: 13px; }
    th, td { font-size: 13px; border-bottom: 1px solid #222; padding: 8px; text-align: center; }
    .status.Win { color: lime; font-weight: bold; }
    .status.Loss { color: #ff6b6b; font-weight: bold; }
    .status.Waiting { color: #ffd54f; font-weight: bold; }
    #colorPredictionBox { color: #ffd700; margin-top: 6px; font-weight: bold; }
    .small-note { color: #999; font-size: 12px; margin-top: 8px; }
    .container { display:flex; gap:12px; align-items: flex-start; justify-content: center; flex-wrap:wrap; }
    .left, .right { width: 100%; max-width: 440px; }
    @media(min-width:980px){ .left, .right { width: 48%; } }
  </style>
</head>
<body>
  <div class="header">ü§ñ THE AI PREDICTOR V5.4 ‚Äî Numbers ¬∑ Color ¬∑ History ¬∑ Ding</div>

  <div class="card container">
    <div class="left">
      <div id="currentPeriod">‡§Æ‡•å‡§ú‡•Ç‡§¶‡§æ ‡§∞‡§æ‡§â‡§Ç‡§°: ‡§≤‡•ã‡§° ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...</div>
      <div id="liveTime">‡§∏‡§Æ‡§Ø: --:--:--</div>
      <div id="predictionBox" class="prediction-btn">Big/Small ‚Üí Analyzing...</div>
      <div id="confidenceBox">Confidence: --%</div>
      <div id="patternBox">‡§™‡•à‡§ü‡§∞‡•ç‡§®: --</div>
      <div class="small-note">‡§®‡•ã‡§ü: ‡§Ø‡§π ‡§∏‡§Ç‡§≠‡§æ‡§µ‡•ç‡§Ø‡§§‡§æ (probability) ‡§π‡•à ‚Äî 100% ‡§ó‡§æ‡§∞‡§Ç‡§ü‡•Ä ‡§®‡§π‡•Ä‡§Ç‡•§</div>
    </div>

    <div class="right">
      <div id="numberPredictionBox" style="font-weight:bold; margin-bottom:6px;">üéØ ‡§∏‡§Ç‡§≠‡§æ‡§µ‡§ø‡§§ ‡§ú‡•Ä‡§§‡§®‡•á ‡§µ‡§æ‡§≤‡•á ‡§®‡§Ç‡§¨‡§∞: --</div>
      <div id="colorPredictionBox" style="font-weight:bold; margin-bottom:6px;">üé® ‡§∏‡§Ç‡§≠‡§æ‡§µ‡§ø‡§§ ‡§∞‡§Ç‡§ó: --</div>
      <div style="margin-top:8px; font-size:13px; color:#aaa; text-align:left;">
        <div><strong>‡§ï‡•à‡§∏‡•á ‡§ï‡§æ‡§Æ ‡§ï‡§∞‡§§‡§æ ‡§π‡•à:</strong></div>
        <div>‡§™‡§ø‡§õ‡§≤‡•á ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ‡•ã‡§Ç ‡§ï‡§æ ‡§∏‡§Ç‡§ï‡•ç‡§∑‡•á‡§™ (hot/cold) ‡§¶‡•á‡§ñ‡§ï‡§∞ Top-3 ‡§∏‡§Ç‡§≠‡§æ‡§µ‡§ø‡§§ ‡§®‡§Ç‡§¨‡§∞ ‡§î‡§∞ ‡§∞‡§Ç‡§ó ‡§®‡§ø‡§ï‡§æ‡§≤‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à‡•§</div>
      </div>
    </div>
  </div>

  <div class="tab-buttons" role="tablist" aria-label="Tabs" style="max-width:900px;margin:0 auto 12px;">
    <button id="predTab" class="active">Prediction History</button>
    <button id="gameTab">Game History</button>
  </div>

  <div class="history-container">
    <table>
      <thead id="tableHead"></thead>
      <tbody id="tableBody"><tr><td style="padding:20px;">‡§≤‡•ã‡§° ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...</td></tr></tbody>
    </table>
  </div>

<script>
/* ====== Config (APIs) ====== */
const CURRENT_API = 'https://api.bdg88zf.com/api/webapi/GetGameIssue';
const HISTORY_API = 'https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json';

const REQUEST_DATA = {
  typeId: 1,
  language: 0,
  random: "e7fe6c090da2495ab8290dac551ef1ed",
  signature: "1F390E2B2D8A55D693E57FD905AE73A7",
  timestamp: 1723726679
};

/* ====== State ====== */
let last100Results = []; // recent results fetched from API
let predictionHistory = []; // saved predictions with status
let winCount = 0, lossCount = 0;

/* For change detection and ding */
let lastShownNumbers = null;
let lastShownColor = null;

/* ====== Persistence (localStorage) ====== */
const STORAGE_KEYS = {
  PH: 'ai_pred_v5_ph',
  WL: 'ai_pred_v5_wl'
};

function loadState() {
  try {
    const ph = localStorage.getItem(STORAGE_KEYS.PH);
    const wl = localStorage.getItem(STORAGE_KEYS.WL);
    if (ph) predictionHistory = JSON.parse(ph);
    if (wl) {
      const obj = JSON.parse(wl);
      winCount = obj.win || 0;
      lossCount = obj.loss || 0;
    }
  } catch(e) { console.warn("Load state error", e); }
}

function saveState() {
  try {
    localStorage.setItem(STORAGE_KEYS.PH, JSON.stringify(predictionHistory));
    localStorage.setItem(STORAGE_KEYS.WL, JSON.stringify({ win: winCount, loss: lossCount }));
  } catch(e) { console.warn("Save state error", e); }
}

/* ====== Helpers ====== */
function getBigSmall(num) { return Number(num) >= 5 ? "Big" : "Small"; }
function getColor(num) {
  if ([1,3,7,9].includes(Number(num))) return "Green";
  if ([2,4,6,8].includes(Number(num))) return "Red";
  return "Violet";
}
function updateLiveTime() { document.getElementById("liveTime").innerText = "‡§∏‡§Æ‡§Ø: " + new Date().toLocaleTimeString('hi-IN'); }

/* Analyze numbers: frequency + last-seen distance */
function analyzeNumbers(history) {
  const numbers = Array.from({length:10}, (_,i)=>i);
  const stats = {};
  numbers.forEach(n => { stats[n] = { frequency: 0, lastSeenIndex: null, color: getColor(n) }; });
  // history[0] is most recent
  for (let i = 0; i < history.length; i++) {
    const n = Number(history[i].number);
    if (stats.hasOwnProperty(n)) {
      stats[n].frequency++;
      if (stats[n].lastSeenIndex === null) stats[n].lastSeenIndex = i; // how many draws since last seen
    }
  }
  // if never seen, lastSeenIndex = history.length (far)
  numbers.forEach(n => { if (stats[n].lastSeenIndex === null) stats[n].lastSeenIndex = history.length; });
  return stats;
}

/* Build prediction object: top3 numbers + color */
function predict(history) {
  if (!history || history.length < 5) {
    return {
      bigsmall: "--",
      conf: "--",
      pattern: "‡§°‡•á‡§ü‡§æ ‡§ï‡§Æ ‡§π‡•à",
      numbers: ["--","--","--"],
      numConf: ["--","--","--"],
      color: "--",
      colorConf: "--"
    };
  }

  // Big/Small simple (trend)
  const bsCounts = history.slice(0,20).reduce((acc,h) => {
    const s = getBigSmall(h.number);
    acc[s] = (acc[s]||0) + 1; return acc;
  }, {});
  const baseBS = (bsCounts.Big || 0) > (bsCounts.Small || 0) ? "Small" : "Big";
  const bsConf = 70;

  // Number analysis (use last100Results if available)
  const stats = analyzeNumbers(last100Results.length? last100Results : history);
  // sort by frequency desc, tie-breaker: more recently seen (smaller lastSeenIndex)
  const sorted = Object.entries(stats).sort((a,b)=>{
    if (b[1].frequency !== a[1].frequency) return b[1].frequency - a[1].frequency;
    return a[1].lastSeenIndex - b[1].lastSeenIndex;
  });

  const totalFreq = Object.values(stats).reduce((s,x)=>s + x.frequency, 0) || 1;
  const top3 = sorted.slice(0,3).map((entry, idx) => {
    const num = Number(entry[0]);
    const freq = entry[1].frequency;
    const freqScore = Math.round((freq / totalFreq) * 100);
    const base = 80 - idx*5;
    const conf = Math.min(95, Math.max(30, Math.round(base + freqScore * 0.12)));
    return { number: num, conf: conf, color: entry[1].color };
  });

  // Color analysis: count colors in recent history
  const colorCount = { Green:0, Red:0, Violet:0 };
  (last100Results.length ? last100Results : history).forEach(h => colorCount[getColor(h.number)]++);
  const topColorEntry = Object.entries(colorCount).sort((a,b)=>b[1]-a[1])[0] || ["Green",0];
  const topColor = topColorEntry[0];
  const colorConf = Math.min(95, 50 + Math.round((topColorEntry[1] / (history.length||1)) * 50));

  return {
    bigsmall: baseBS,
    conf: bsConf,
    pattern: "AI Hot-Trend + Color",
    numbers: top3.map(t=>t.number),
    numConf: top3.map(t=>t.conf),
    color: topColor,
    colorConf: colorConf
  };
}

/* ====== Audio (soft ding) ====== */
let audioCtx = null;
function playDingSoft() {
  try {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.value = 880; // soft high tone
    g.gain.setValueAtTime(0, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0.08, audioCtx.currentTime + 0.01);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.22);
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + 0.22);
  } catch(e){ console.warn("Audio error", e); }
}

/* ====== Fetch + UI update ====== */
function updateWinRateDOM() {
  const total = winCount + lossCount;
  const winRate = total>0 ? Math.round((winCount/total)*100) : 0;
  // small place to show it inside patternBox
  const p = document.getElementById('patternBox');
  if (p) p.innerText = `‡§™‡•à‡§ü‡§∞‡•ç‡§®: ${currentPrediction?.pattern || '--'} ‚Ä¢ WinRate: ${winRate}% (${winCount}W/${lossCount}L)`;
}

/* render tables for tabs */
function renderTable() {
  const head = document.getElementById("tableHead");
  const body = document.getElementById("tableBody");
  const isPredTab = document.getElementById("predTab").classList.contains("active");

  if (isPredTab) {
    head.innerHTML = `<tr>
      <th>Period</th><th>Big/Small Pred</th><th>Top Numbers (conf)</th><th>Actual</th><th>Status</th>
    </tr>`;
    if (!predictionHistory.length) {
      body.innerHTML = `<tr><td colspan="5">‡§ï‡•ã‡§à predictions ‡§®‡§π‡•Ä‡§Ç</td></tr>`;
    } else {
      body.innerHTML = predictionHistory.map(item=>{
        const nums = (item.numberPreds || ["--","--","--"]).map((n,i)=> `${n} (${(item.numConfs||[])[i]??'--'}%)`).join(", ");
        const actualText = item.actualNum ? `${item.actualNum} (${item.actual})` : '--';
        const statusClass = item.status === 'Win' ? 'Win' : (item.status === 'Loss' ? 'Loss' : 'Waiting');
        return `<tr>
          <td>${item.period}</td>
          <td>${item.prediction}</td>
          <td>${nums}</td>
          <td>${actualText}</td>
          <td class="status ${statusClass}">${item.status}</td>
        </tr>`;
      }).join("");
    }
  } else {
    head.innerHTML = `<tr>
      <th>Period</th><th>Number</th><th>Big/Small</th><th>Color</th>
    </tr>`;
    if (!last100Results.length) {
      body.innerHTML = `<tr><td colspan="4">‡§ï‡•ã‡§à ‡§á‡§§‡§ø‡§π‡§æ‡§∏ ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç</td></tr>`;
    } else {
      body.innerHTML = last100Results.slice(0, 50).map(item=>{
        return `<tr>
          <td>${item.period}</td>
          <td>${item.number}</td>
          <td>${item.size}</td>
          <td>${getColor(item.number)}</td>
        </tr>`;
      }).join("");
    }
  }
}

/* match predictions with actuals and update history state (avoid double counting) */
function resolvePredictions() {
  predictionHistory.forEach(ph=>{
    if (!ph.resolved) {
      const match = last100Results.find(r => r.period === ph.period);
      if (match) {
        ph.actualNum = match.number;
        ph.actual = match.size;
        ph.status = (ph.prediction === match.size) ? 'Win' : 'Loss';
        ph.resolved = true;
        if (ph.status === 'Win') winCount++; else lossCount++;
      }
    }
  });
  saveState();
}

/* keep one global currentPrediction for display in pattern box */
let currentPrediction = null;

/* main fetch function */
async function fetchData() {
  try {
    // fetch current period (best-effort)
    try {
      const periodRes = await fetch(CURRENT_API, {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ...REQUEST_DATA, timestamp: Math.floor(Date.now()/1000) })
      });
      const periodData = await periodRes.json();
      const period = periodData?.data?.issueNumber || "Unavailable";
      document.getElementById("currentPeriod").innerText = `‡§Æ‡•å‡§ú‡•Ç‡§¶‡§æ ‡§∞‡§æ‡§â‡§Ç‡§°: ${period}`;
    } catch(e){
      document.getElementById("currentPeriod").innerText = `‡§Æ‡•å‡§ú‡•Ç‡§¶‡§æ ‡§∞‡§æ‡§â‡§Ç‡§°: Unavailable`;
    }

    // fetch history
    const res = await fetch(HISTORY_API + '?ts=' + Date.now());
    const data = await res.json();
    if (!data?.data?.list) throw new Error("Invalid history response");
    last100Results = data.data.list.slice(0, 100).map(item => ({
      period: item.issueNumber,
      number: parseInt(item.number,10),
      size: getBigSmall(item.number)
    }));

    // compute prediction using recent 50 draws
    const recent = last100Results.slice(0, 50);
    const prediction = predict(recent);

    // update top UI
    document.getElementById("predictionBox").innerText = `Big/Small ‚Üí ${prediction.bigsmall}`;
    document.getElementById("confidenceBox").innerText = `Confidence: ${prediction.conf}%`;
    document.getElementById("patternBox").innerText = `‡§™‡•à‡§ü‡§∞‡•ç‡§®: ${prediction.pattern}`;

    const numberText = prediction.numbers.map((n,i)=> `${n} (${prediction.numConf[i]}%)`).join(", ");
    document.getElementById("numberPredictionBox").innerText = `üéØ ‡§∏‡§Ç‡§≠‡§æ‡§µ‡§ø‡§§ ‡§ú‡•Ä‡§§‡§®‡•á ‡§µ‡§æ‡§≤‡•á ‡§®‡§Ç‡§¨‡§∞ ‚Üí ${numberText}`;
    document.getElementById("colorPredictionBox").innerText = `üé® ‡§∏‡§Ç‡§≠‡§æ‡§µ‡§ø‡§§ ‡§ú‡•Ä‡§§‡§®‡•á ‡§µ‡§æ‡§≤‡§æ ‡§∞‡§Ç‡§ó ‚Üí ${prediction.color} (${prediction.colorConf}%)`;

    // record prediction for current period
    const currPeriodText = document.getElementById("currentPeriod").innerText;
    const currentPeriod = currPeriodText.split(':')[1]?.trim() || null;
    if (currentPeriod && currentPeriod !== 'Unavailable') {
      // add if not exists
      if (!predictionHistory.find(p => p.period === currentPeriod)) {
        const rec = {
          period: currentPeriod,
          prediction: prediction.bigsmall,
          numberPreds: prediction.numbers,
          numConfs: prediction.numConf,
          actual: null,
          actualNum: null,
          status: 'Waiting',
          resolved: false
        };
        predictionHistory.unshift(rec);
        if (predictionHistory.length > 200) predictionHistory.pop();
      }
    }

    // resolve any waiting predictions by matching actuals
    resolvePredictions();

    // save state
    saveState();

    // decide if ding required (numbers array equality or color change)
    const numbersChanged = !arrayEquals(prediction.numbers, lastShownNumbers);
    const colorChanged = prediction.color !== lastShownColor;

    if (numbersChanged || colorChanged) {
      // soft ding
      playDingSoft();
      lastShownNumbers = prediction.numbers ? prediction.numbers.slice() : null;
      lastShownColor = prediction.color;
    }

    currentPrediction = prediction;
    updateWinRateDOM();
    renderTable();

  } catch (err) {
    console.error("Fetch error:", err);
    document.getElementById("numberPredictionBox").innerText = "‡§°‡•á‡§ü‡§æ ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø!";
  }
}

/* array equality for numbers */
function arrayEquals(a,b){
  if (!a && !b) return true;
  if (!a || !b) return false;
  if (a.length !== b.length) return false;
  for (let i=0;i<a.length;i++) if (a[i] !== b[i]) return false;
  return true;
}

/* ====== Tabs wiring ====== */
document.querySelectorAll(".tab-buttons button").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    document.querySelectorAll(".tab-buttons button").forEach(b=>b.classList.remove("active"));
    btn.classList.add("active");
    renderTable();
  });
});

/* ====== Init ====== */
loadState();
updateLiveTime();
setInterval(updateLiveTime, 1000);
setInterval(fetchData, 7000); // fetch every 7 seconds
fetchData(); // first fetch

// Unlock audio on first user gesture (required on some browsers)
document.body.addEventListener('click', function unlockAudio(){
  try {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
  } catch(e){}
  document.body.removeEventListener('click', unlockAudio);
}, { once: true });

</script>
</body>
</html>
